# MongoDB & Mongoose â€“ Simple Notes with Examples

---

## 1. What is Aggregation?

**Aggregation** means writing a **complex query** that processes data step by step inside the database.

It can:

* filter data
* group data
* calculate values (count, average, sum)
* reshape output
* join collections

ðŸ‘‰ Think of aggregation as **advanced querying**.

---

## 2. What is a Pipeline?

A **pipeline** is a **sequence of steps** where data flows from top to bottom.

Each step is called a **stage**.

### Example pipeline

```js
[
  { stage1 },
  { stage2 },
  { stage3 }
]
```

Real-life idea: factory assembly line.

---

## 3. `.find()` vs `.aggregate()`

### `.find()`

* Fetches documents
* Simple filtering

```js
User.find({ age: { $gte: 18 } })
```

### `.aggregate()`

* Fetches + processes data
* Supports grouping, calculations, joins

```js
User.aggregate([
  { $match: { age: { $gte: 18 } } },
  { $group: { _id: "$country", count: { $sum: 1 } } }
])
```

**Rule:**

> If `find()` can do it, use `find()`.
> If not, use `aggregate()`.

---

## 4. Common Aggregation Operators

### `$match`

Filters documents (like `find`).

```js
{ $match: { price: { $gt: 100 } } }
```

---

### `$group`

Groups documents and performs calculations.

```js
{
  $group: {
    _id: "$category",
    avgPrice: { $avg: "$price" },
    count: { $sum: 1 }
  }
}
```

**Meaning:**

* Group by category
* Calculate average price
* Count items per category

---

### `$project`

Controls **what fields appear in the output**.

```js
{
  $project: {
    name: 1,
    price: 1,
    _id: 0
  }
}
```

Used to:

* include / exclude fields
* rename fields
* create new fields

---

### `$sort`, `$limit`

```js
{ $sort: { price: -1 } }
{ $limit: 5 }
```

---

## 5. Grouping (Very Important)

**Grouping** means:

> Putting similar documents together and calculating values for each group.

### Example data

```js
{ category: "electronics", price: 100 }
{ category: "electronics", price: 200 }
{ category: "clothing", price: 50 }
```

### Grouped result

```js
{ _id: "electronics", avgPrice: 150, count: 2 }
{ _id: "clothing", avgPrice: 50, count: 1 }
```

---

## 6. Full Aggregation Example

```js
const items = await Product.aggregate([
  {
    $match: {
      inStock: true,
      price: { $gt: 100 }
    }
  },
  {
    $group: {
      _id: "$category",
      avgPrice: { $avg: "$price" },
      count: { $sum: 1 }
    }
  },
  {
    $project: {
      category: "$_id",
      avgPrice: 1,
      count: 1,
      _id: 0
    }
  }
])
```

---

## 7. Document References

Instead of storing full data, MongoDB stores **IDs**.

```js
// Post
{ title: "Hello", userId: ObjectId("123") }
```

---

## 8. `.populate()` Method (Mongoose)

**`.populate()` replaces an ID with the actual document.**

### Without populate

```js
Post.find()
```

```js
{ title: "Hello", userId: "123" }
```

### With populate

```js
Post.find().populate("userId")
```

```js
{
  title: "Hello",
  userId: { name: "Alice", email: "a@email.com" }
}
```

---

## 9. `.populate()` vs `$lookup`

| populate         | $lookup                 |
| ---------------- | ----------------------- |
| Mongoose feature | MongoDB feature         |
| Easy to use      | Very powerful           |
| Simple joins     | Complex joins & reports |

---

## 10. Key Takeaways

* Aggregation = complex queries
* Pipeline = step-by-step processing
* `$match` filters data
* `$group` combines data
* `$project` shapes output
* `.populate()` fetches referenced documents

---

## One-Line Summary

> Aggregation processes data step by step, grouping and transforming it, while populate simply replaces referenced IDs with real documents.
